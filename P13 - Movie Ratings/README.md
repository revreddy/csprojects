###Project 13 - Movie Ratings

---
#####Description
We are going to analyze Netflix movie reviews. There are 2 text files, one containing movie reviews, and one containing the names of the movies. Assume the reviews file is called “reviews.txt”, and the movies file is called “movies.txt”. The reviews file will contain N > 0 reviews, one per line, in this format:
	movieid, userid, rating, dateThe movie ids will range from 1..M, the rating is a value in the range [1,5], and userid is an integer. The movies file will contain M movies, one per line, in this format:	movieid, movienameThe movies file is always in order by id: 1, 2, 3, ... Assume that if a review refers to movie X, then a movie with id X exists in the movies file.Note that we are providing text files for you to test against; we reserve the right to test against different text files to ensure you have written a general-purpose program. Two different reviews files are provided — a larger 100+ MB file is provided so you can test the efficiency of your solution. While you are not required to provide a sub-second solution for the 100+ MB file, you are expected to (a) run your program against this large input file, and (b) improve your program as necessary so execution time < 5 minutes. Once again it’s not just about solving the problem, but solving it reasonably well.For best execution time in Visual Studio, change the “Solution Configuration” drop-down in the toolbar from “Debug” to “Release”, and then use Ctrl+F5 to run (“Start without debugging”).

---
#####Requirements:

Write a program that analyzes a pair of reviews and movies files, and outputs the following information to the screen:
1. The top 10 movies based on average rating. Output the movies in descending order by average rating. For each movie, output: the id, the name, the average rating, and the total number of reviews. If 2 movies have the same rating, output in ascending order by movie name. You may assume that the number of movies M >= 10.2. The top 10 users based on the number of reviews they submitted. Output the users in descending order by number of reviews. For each user, output: id, total number of reviews submitted. If 2 users have the same number of reviews, output in ascending order by user id. You may assume that the number of users U >= 10.3. Input a movie id from the user, confirm it is in the range 1..M, and then analyze the data for that movie. Output the movie name, the average rating, the total number of reviews, and then the breakdown of ratings: the number of reviews with a rating of 1, number of reviews with a rating of 2, etc. Repeat for all 5 ratings. If the user inputs an invalid movie id, output an error message and ignore.4. Repeat step 3 until the user enters 0. At this point the program ends.

---
##### Guidelines:

In general, you are free to use any of the features of C++, as well as any of the components of the standard library. However, outside libraries are not permitted. Use modern C++, not C. Use the provided containers and algorithms as much as possible; you can solve this assignment efficiently using vector<T> and sort. Other requirements to ensure a modern solution:
1. Whenever possible, use range-for loops, or iterator-based loops. For example, to output the top-10 it makes sense to use an index-based counting loop, but that should be it.2. Do not open/close the file yourself. Instead, use ifstream + getline( ) approach shown earlier.3. Avoid the use of pointers, new and malloc.4. Define a class movie to the hold the data about an individual movie, and a class review to hold the data for an individual review. Feel free to define additional classes.5. Use a C++ container + class movie to store the movie data, and a C++ container + class review to store the review data. While you can use whatever container you want, vector<T> is a good choice.6. If you need to sort, use the built-in sort algorithm + a lambda expression. No function pointers, no function objects, and do not write sort yourself.7. If you need to search, use the built-in search algorithms + lambda expressions: find, find_if and binary_search. No function pointers, no function objects, and do not write the search yourself.